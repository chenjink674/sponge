// Package router is to generate gin router code.
package router

import (
	"bytes"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/descriptorpb"

	"github.com/zhufuyi/sponge/cmd/protoc-gen-go-gin/internal/parse"
)

const (
	stringsPkg         = protogen.GoImportPath("strings")
	contextPkg         = protogen.GoImportPath("context")
	errcodePkg         = protogen.GoImportPath("github.com/zhufuyi/sponge/pkg/errcode")
	middlewarePkg      = protogen.GoImportPath("github.com/zhufuyi/sponge/pkg/gin/middleware")
	zapPkg             = protogen.GoImportPath("go.uber.org/zap")
	ginPkg             = protogen.GoImportPath("github.com/gin-gonic/gin")
	ginBindingPkg      = protogen.GoImportPath("github.com/gin-gonic/gin/binding")
	deprecationComment = "// Deprecated: Do not use."
)

// GenerateFile generates a *_router.pb.go file.
func GenerateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	if len(file.Services) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_router.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by https://github.com/zhufuyi/sponge, DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	// check whether the service method contains the form-data parameter
	needGinBindingPkg := false
	for _, s := range file.Services {
		for _, m := range s.Methods {
			for _, rpcm := range parse.GetMethods(m) {
				if rpcm.Method == "FORM-DATA" {
					needGinBindingPkg = true
					break
				}
			}
			if needGinBindingPkg {
				break
			}
		}

	}
	if needGinBindingPkg {
		g.P("// import packages: ", stringsPkg.Ident(" "), contextPkg.Ident(" "), errcodePkg.Ident(" "),
			middlewarePkg.Ident(" "), zapPkg.Ident(" "), ginPkg.Ident(" "), ginBindingPkg.Ident(" "))
	} else {
		g.P("// import packages: ", stringsPkg.Ident(" "), contextPkg.Ident(" "), errcodePkg.Ident(" "),
			middlewarePkg.Ident(" "), zapPkg.Ident(" "), ginPkg.Ident(" "))
	}

	g.P()

	for _, s := range file.Services {
		genService(file, g, s)
	}
	return g
}

func genService(file *protogen.File, g *protogen.GeneratedFile, s *protogen.Service) {
	if s.Desc.Options().(*descriptorpb.ServiceOptions).GetDeprecated() {
		g.P("//")
		g.P(deprecationComment)
	}

	// HTTP Server.
	sd := &tmplField{
		Name:      s.GoName,
		LowerName: strings.ToLower(s.GoName[:1]) + s.GoName[1:],
		FullName:  string(s.Desc.FullName()),
		FilePath:  file.Desc.Path(),
	}

	for _, m := range s.Methods {
		sd.Methods = append(sd.Methods, parse.GetMethods(m)...)
	}

	g.P(sd.execute())
}

type tmplField struct {
	Name      string // Greeter
	LowerName string // greeter
	FullName  string // v1.Greeter
	FilePath  string // api/v1/demo.proto

	Methods []*parse.RPCMethod
}

func (s *tmplField) execute() string {
	buf := new(bytes.Buffer)
	if err := handlerTmpl.Execute(buf, s); err != nil {
		panic(err)
	}
	return buf.String()
}
